## mysql中的锁



### 全局锁

- 对整个数据库实例加锁
- mysql添加全局读锁的方法：FTWRL, Flash tables with read lock，使用这个命令，`数据的变更语句`，`建表语句`和`更新类事务的提交语句`都会被阻塞
- 使用场景：做全库逻辑备份，把每个表都select出来存成文本
  - 备份为什么要加锁
    - 如果不加锁，会导致视图逻辑不一致
      - 假设现在备份一个购买系统，关注的两张表是余额表和课程表
      - 当购买一门课程的时候，先在余额表扣除，然后再往课程表添加一条课程记录
      - 假设从时间顺序上先备份余额表，用户购买，再备份课程表，那么就有可能导致两张表的逻辑不一致

  - 有了mysqldump，为什么还需要FTWRL
    - mysqldump可以通过`--single-transaction`参数在导数据之前启动一个事务来获取一致性视图，`--single-transaction`只适合所有表使用了事务引擎的库
    - 对于不支持的一致性读这种隔离级别的引擎来说，在备份的时候总能拿到最新更新的数据，那么就需要FTWRL命令来加锁备份，保持一致性
  - 全库只读，为什么不用set global readonly=true?
    - 执行FTWRL命令的客户端发生异常断开的时候，mysql会断开这个全局锁
    - 如果将整个库设置成readonly之后，客户端发生异常，mysql会一直处于readonly状态，会导致整个库长时间处于不可写状态

### 表级锁

给一个表`加字段`，`修改字段`，或者`加索引`，需要扫描全表的数据

- 表锁
  - 语法：lock tables [table_name] read / write
  - lock tables 限制了其他线程的读写，也限定了当前线程接下来的操作对象
  - 一般是引擎不支持行锁的情况下才考虑使用表锁



- 元数据锁MDL
  - 语句执行开始时申请，等到整个事务提交后再释放
  - mdl的作用是保证读写的正确性
  - 对一个表进行`增删改查`的时候，加mdl读锁
  - 对表结构变更操作的时候，加mdl写锁
  - 读锁之间不互斥，读写之间，写锁之间互斥，串行化


- 如何安全的给小表加字段
  - mysql.information_schema.innodb_trx表记录正在执行的事务
  - 在做DDL表更的时候刚好有长事务在执行，先暂停DDL,或者kill掉这个长事务

- 如何变更一个热点表（数据量不大，但请求很频繁）
  - 在`alter table`语句设定等待时间
  - 在这个时间内能拿到mdl锁最好，拿不到的话先放弃执行，不阻塞后面的业务语句
  - 之后再继续重复这个过程


### 行锁

- 在引擎层实现
- 不支持行锁的引擎说明并发控制只能用表锁，同时只能有一个更新在执行
- 行锁是针对数据表中行记录的锁
  - 假设a事务更新了1行，此时b事务也要来更新同一行，那么只能等a事务结束之后才能更新
- 两阶段锁协议
  - 在innodb中，行锁是在需要的时候加上的，等到事务结束时才释放，这个就是两阶段锁协议
  - 如果事务中需要锁多个行，要把最可能造成锁冲突的锁尽量往后放

- 死锁 && 死锁检测
  - 不同线程出现来循环资源依赖，进入了无限等待的状态，称为死锁
  - 出现死锁的解决方案
    - 通过设置innodb_lock_wait_timeout参数，当出现死锁的时候，等待一段时间后超时
    - 死锁检测，设置参数innodb_deadlock_detect=on,当发生死锁的时候，主动回滚死锁链条的某个事务，让其他事务可以继续执行
      - 存在问题
        - 开启了死锁检测的时候，如果有一个事务a锁住了，新进来的事务也想更新统一行记录，它会判断会不会由于自己的加入导致了死锁，这个是On的操作，当线程数多了之后，就会出现大量浪费cpu资源，但是没有执行很多事务
        - 解决方案
          - 如果可以确定这个业务不会发生死锁，可以把innodb_deadlock_detect关闭
          - 控制并发度，控制同一行只有10个线程在更新，死锁检测的成本就很低；如果客户端很多的话，那就可以尝试修改mysql的源码，对于相同行的更新，在进入引擎前排队
