## 索引


索引的出现是为了提高数据检索的效率



### 索引的常见数据类型

- hash
  - 适合等值查询场景
- 有序数组
  - 连续的内存空间
  - 适合范围查询
  - 插入数据或者删除数据的成本较高
  - 适合静态存储引擎，即不再修改的数据
- 搜索树
  - 使用n叉树，因为索引要落磁盘，所以需要减少磁盘io的次数，也就是需要降低树的高度
  - 索引是引擎实现的
  - 左子树 < 父节点 < 右子树
  - 查询的复杂度是logN，为了保证查询的复杂度，更新的复杂度也为logN




### InnoDB的索引模型


- 索引组织表：表根据主键顺序以索引的形式存放
- InnoDB使用B+树索引模型
- 索引类型
  - 主键索引（聚簇索引）
  - 非主键索引（二级索引）

- 查询方式
  - 主键索引
    - 只需要根据主键的值去B+树找到对应的记录返回
  - 非主键索引
    - 先搜索普通索引树，得到要找的那条记录的主键值，然后根据这个值去主键B+树中找到对应的记录，然后返回




### 索引维护

- 为了保证B+树索引的有序性，在进行插入操作的时候需要进行必要的维护
- 维护的两个难点
  - 如果在id=500的记录后面插入id=400的记录，需要进行数据迁移，并且保证其有序性
  - 如果插入的时候id=500所在的数据页满了，这时候需要申请一个新的页（16kb），判断哪些旧数据需要迁移，加上新的数据进行迁移，这个过程成为页分裂
- 自增主键
  - 每次插入一条新记录都是追加操作
  - 不涉及挪动其他记录
  - 不会触发叶子节点的分裂
  - 普通索引树的叶子节点存储的是该记录的主键值，所以主键索引越小，普通索引树的叶子节点就越小，占用的空间也就越小



### select的执行流程（普通索引）

- 通过普通索引树找到对应记录的主键的值
- 通过找到的主键值去主键索引树找到对应的那条记录的值
- 回表：回到主键索引树搜索的过程




### 覆盖索引

- 要查找的数据刚好是主键的值，也就是通过普通索引去找的话，刚好落在普通索引树的叶子节点上



### 最左前缀原则

- 索引项按照索引定义里面出现的字段顺序排序的
- 最左前缀原则
  - 联合索引的最左N个字段
  - 字符串索引的最左M个字符
- 联合索引的字段顺序
  - 调整顺序可少维护一个索引，这个顺序往往是有限考虑采用的
  - 空间


### 索引下推

- mysql 5.6引入
- 在进行索引遍历的过程中，对索引包含的字段进行判断，过滤掉不满足条件的记录，减少回表记录



### 普通索引 && 唯一索引


- 普通索引的查询过程：查找到满足条件到第一个记录后，会继续往下查，直到碰到第一个不满足条件到记录
- 唯一索引的查询过程：找到满足条件的第一个记录后，停止查找
- innodb的数据是按`数据页`为单位来读写的，数据页的默认大小是16kb，当需要读一条记录的时候，是将记录所在的数据页从磁盘读出来
- 当需要更新一个数据页当时候，如果数据页在内存中就直接更新；如果不在内存中，那么就将更新操作缓存到`change buffer`中，等下次需要查询这个数据页等时候，再将数据页等内容读入内存，然后将change buffer中的操作应用到原数据页，这个过程称为merge（访问数据页，数据库正常关闭以及后台线程定期都会进行merge操作），保证这个页逻辑的一致
- change buffer的使用场景
  - 唯一索引的更新操作都需要先判断这个操作是否违反来唯一性，也就是需要读到内存中才能判断，所以change buffer不适合唯一索引的更新操作
  - change buffer用的是buffer pool的内存，可以通过`innodb_change_buffer_max_size`这个参数来动态设置，当设置为50时，change buffer只能使用buffer pool 50%的内存
  - 唯一索引和普通索引的选择
    - 尽量使用普通索引并且把change buffer开大，以确保这个历史数据的数据写入速度
    - 如果在所有的更新后面，都马上伴随着对这个记录的查询，那么就应该关闭change buffer，其他情况下，change buffer都可以提升性能
    - change buffer适用与写多读少的场景



- redolog 和 change buffer 的区别
  - insert into t(id,k) values(id1,k1),(id2,k2)
  - select * from t where k in (k1,k2)
  - 假设k1所在的数据页在内存中，k2所在的数据页不在内存中
    - 当执行k1插入操作的时候，直接更新内存
    - 当执行k2插入操作的时候，写入到change buffer中
    - 将两次操作写入redolog
    - 后面读k1的时候，直接从内存返回；读k2的时候，需要将k2所在的数据页load到内存中，和change buffer一起组装一个新版本返回
  - redolog节省的是随机写磁盘io的成本，change buffer节省的是随机读磁盘io的成本